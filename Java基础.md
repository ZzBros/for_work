## 基础

### default 关键字
使得抽象类和接口可以有默认的方法实现

### 字符串常量池
JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。
- 字符串常量池中保存的是堆中字符串常量的引用
- 一个从未出现过的字符串常量赋值给一个Strig变量时，只会在堆中创建一个对象，并将其引用添加至字符串常量池中
- 一个从未出现过的字符串常量通过调用String构造函数初始化后赋值给String变量时，会在堆中创建两个对象，一是字符串常量对象，另一个是字符串对象。字符串常量对象的引用会被添加至字符串常量池中。

### 引用类型
- 强引用：只要存在强引用，就永远不会被回收
- 软引用：指向那些还有用但非必须的对象，JVM内存不足时会进行回收，当回收这些对象仍然内存不足时会OOM
- 弱引用：指向那些非必须对象，本次GC不会被回收，但下次GC发现即回收
- 虚引用：用来指引程序发现被引用的对象会被回收了

### 内存区域

#### 堆 - Java虚拟机内
一般类实例都存放在这边，GC还负责管理这块的内容。字符串常量池在jdk1.7以后加入到这块区域，为了更好的回收用不到的字符串常量。静态变量也存这块。

#### 虚拟机栈 - Java虚拟机内
线程内java方法的局部变量，方法调用等

#### 本地方法栈 - Java虚拟机内
线程内本地方法的局部变量，方法调用等

#### 程序计数器 - Java虚拟机内
线程字节码执行位置的表示，用于上下文切换

#### 元空间 - 本地内存内
Java虚拟机加载的类信息、运行时常量池、代码缓存

#### 直接内存 - 本地内存内
用于临时开辟java堆空间

### 类加载机制

#### 类加载器至顶向下
1. BootStrap ClassLoader 根加载器
2. Extension ClassLoader 拓展加载器
3. App ClassLoader 引用程序加载器
4. User Define ClassLoader 用户自定义加载器

#### 加载机制
- 双亲委托：先让父类加载器（上一级加载器）加载该Class，若无法加载再由本类加载器加载，保证重复引入的类只加载一次。
- 全盘负责：当某一个类是由指定的类加载器加载的，那么该类所依赖的其他类也有该类加载器负责。
- 缓存机制：所有已经被加载过的类都会被保存在缓存中，当程序需要某个类时，会首先在缓存中寻找该类，若找不到则会从class二进制文件中加载类并将其转换至Class对象并存入缓存区。

#### 如何打破双亲委派
自定义类加载器 继承 ClassLoader 类后，重写loadClass()，不要委托至父加载器。

### 代码执行流程
这一方面主要是静态代码的执行问题。

```
// a最终为5，b为0
class Test {
    
    public static Test t = new Test();
    public static int a;
    public static int b = 0;

    Test(){
        a = 5;
        b = 5;
    }
}

// a最终为5，b为5
class Test {
    
    public static int a;
    public static int b = 0;
    public static Test t = new Test();

    Test(){
        a = 5;
        b = 5;
    }
}

```

## 容器

### ArrayList扩容策略
1. 判断数组是否为空，若为空则默认扩容值为0，不为空默认扩容值为10
2. 判断传入的最小扩容值是否大于默认扩容值，若大于，则继续
3. 再次判断当前数组是否为空，若为空则需要判断当前扩容值和10的大小，取最大
4. 获取当前数组容量并乘1.5后与当前扩容值进行对比，取较大的
5. 讲当前扩容值与最大容量对比，若大于最大容量值，需要检查传入的最小扩容值是不是小于0，如果最大扩容值要大于最大Int-8，取Int的最大值。

### HashMap扩容策略
HashMap扩容时主要有当前容量、加载因子、是否转红黑树、元素迁移这几方面的注意事项

#### 插入时table为空
将表扩容为16容量，并将元素进行hash后放至确定桶位置。
> 容量一定是2的n次方，因为hash值需要对容量值进行取余，若除数是2的n次方，那么任何数对其取余可以简化为 x&(2的n次方-1)，这是容量为2的n次方的好处。

#### 插入时桶位置为空
直接将元素放入

#### 插入时桶位置不为空
1. 判断当前桶位置的头节点是否为红黑树节点，若是，直接加入红黑树中。
2. 若为链表节点，遍历至链表尾，添加当前元素，若链表长度到达8，并且当前容量大于64，将链表转为红黑树，否则扩容。
3. 添加完元素后，判断是否超过阈值，触发扩容。

#### 扩容
HashMap最大容量值为 `1<<<30`，超过此容量值后就不会再扩容了
1. 每次扩容都为原来的2倍，遵循了2的n次方规则。
2. 计算新threshold
3. 数据transfer分为三种情况，针对当前桶位置而言
    1. 头节点为只有一个元素的链表，直接迁移至新位置
    2. 头节点为红黑树，直接迁移至新位置
    3. 头节点为多个元素的链表，为链表元素计算高低位，低位子链表放至新table的相同位置，高位子链表放至新table的（原始索引+原始容量）

## 多线程

### 线程的状态
- NEW
- RUNNABLE
- BLOCKED
- WAITING
- TIME_WAITING
- TERMINATED

### 锁的类型
- 无锁：MarkWord的数据位分布结构为(25,4,1,2)->(对象的hashCode, 对象分代年龄, 是否有偏向锁0, 锁标志位为01)
- 偏向锁：MarkWord的数据位分布结构为(23,2,1,2)->(线程ID, epoch, 对象分代年龄, 是否有偏向锁1, 锁标志位为01)
- 轻量级锁：MarkWord的数据位分布结构为(30,2)->(指向线程栈锁记录的指针, 锁标志位为00)
- 重量级锁：MarkWord的数据位分布结构为(30,2)->(指向锁监视器的指针, 锁标志位为10)
> 如果锁的对象被人工触发过计算hash操作，那么他最低只能作为轻量级锁，因为偏向锁会修改hashCode处的值


### 死锁的产生
A拥有a资源，申请b资源的同时B拥有b资源且在申请a资源。
1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。

### Java中的锁
1. vloatile 只能修饰修饰类变量、实例变量，保证可见性，但不保证原子性
2. synchronized 可以分为对类和实例的修饰，分别分为类方法、实例方法，类代码块、方法内代码块。锁会有状态的升级、升级为重量级锁时保证可见性、原子性和有序性
3. ReentrantLock 相较于synchronized更为方便，实例化后，可以在代码中的任意位置进行 lock() 然后在后续处理中进行 unlock()
4. Semaphore 初始化信号量后，线程在需要加锁的代码区域 acquire() 获取信号量，完成后，release() 释放信号量。acquire()方法会阻塞线程。tryAcquire()方法在获取不到信号量后会直接返回false。

### AQS队列同步器
使用一个标志位表示当前共享资源是否有线程占用，标志位的修改依赖于CAS。
当某一个线程需要锁时，会进入等待队列，等待队列在满足某些条件的时候会继续唤醒队列中的线程。依据唤醒的顺序可以分为公平和非公平的，公平指的是按照先进先出的方式进行锁的获取，非公平指的是线程抢占。

### 为什么 HashMap 是线程不安全的
多线程下扩容会死循环、多线程下 put 会导致元素丢失、put 和 get 并发时会导致 get 到 null
- 扩容时，在jdk8之前，需要重新对相同hash值的元素的链表重新构建，其中的非原子操作会导致链表出现循环的情况，导致扩容失败。jdk8后已经修复此bug
- put操作时，会先去判断当前hash值的数组元素是否为空，如果为空则是直接赋值新元素，这就导致在多线程的情况下，都判断到空时出现直接赋值覆盖的情况
- 当一个线程去put时触发扩容，因为扩容分为resize和transfer两个步骤，当只resize后，另一个线程使用get获取元素时，就为空

### ConcurrentHashMap是怎么实现线程安全

- 使用sizeCtl控制当前容器的状态，-1表示初始化 -N+1 表示有N个线程正在初始化
- put时使用CAS保证put到空位置时的线程安全
- put时使用锁将不为空的插槽位置头锁住，保证线程安全
- 扩容在transfer方法里面，新table初始化时不管线程间的冲突，扩容时会调用 helpTransfer 使用多线程进行数据迁移，其中在分配每个线程迁移的桶时使用 CAS 控制线程安全，插入时，对新位置的槽加锁，这和put操作相似。
- get操作时不加锁，而是对Node对象的 val变量添加 volatile 关键词修饰，并且table成员变量也添加了volatile 关键词

### 并发容器

#### ConcurrentHashMap
上面已介绍为什么是线程安全的

#### CopyOnWriteArrayList
将数据的修改操作改为在元素数据的副本上进行操作，保证读元素时永远不会出错，但似乎无法保证可见性。

#### ConcurrentLinkedQueue
非阻塞的，基于CAS实现线程安全的队列

#### BlockingQueue
阻塞的，基于锁结构实现

#### ConcurrentSkipListMap



## 线程池

### 常见线程池
0. ThreadPoolExecutor - 可自定义设置线程池的各项参数，推荐使用
1. FixedThreadPool - 可重用固定线程数的线程池，不推荐使用，待执行队列无界，造成OOM
2. SingleThreadExecutor - 只有一个线程的线程池，不推荐使用，仍然事无界队列问题
3. CachedThreadPool - 会根据需要创建新线程的线程池，若主线程提交任务速率过快，会一直创建新线程，导致资源被耗尽
4. ScheduledThreadPoolExecutor - 可以指定延迟或定期执行任务的线程池。

### 线程池阻塞队列类型
- ArrayBlockingQueue （有界队列）：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
- LinkedBlockingQueue （无界队列）：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
- SynchronousQueue（同步队列）: 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法- Executors.newCachedThreadPool使用了这个队列。
- DelayQueue（延迟队列）：一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。
- PriorityBlockingQueue（优先级队列）: 一个具有优先级得无限阻塞队列。

### ThreadPoolExecutor

- corePoolSize - 线程池的核心线程数量
- maximumPoolSize - 线程池的最大线程数
- keepAliveTime - 当线程数大于核心线程数时，多余的空闲线程存活的最长时间
- unit - 时间单位
- workQueue - 任务队列，用来储存等待执行任务的队列
- threadFactory - 线程工厂，用来创建线程，一般默认即可
- handler - 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务

#### 提交任务

```
// 1 执行不需要返回值的任务，worker实现Runnable或者无返回值的Callable<V>
executor.execute(worker);

// 2 执行有返回值和异常的任务，worker实现Callable<V>，返回的类型是Future<V>
executor.submit(worker);
```

#### 停止线程池

```
// 1 关闭线程池，不再接收新任务，已有任务会处理完毕
executor.shutdown();

// 2 直接讲线程终止
executor.shutdownNow();
```

#### 获取返回值

```
Future<String> res = executor.submit(worker);
String result = res.get();

```

### 线程池造成的死锁问题
线程池死锁问题是因为当前线程数量对于不同任务而言是一个共享变量，如果操作不当也会产生死锁问题。
1. 不同任务使用同一个线程池
2. 不同任务之间有调用关系
3. 父任务占满所有核心线程，需要调用子任务并期待其完成
4. 子任务需要获取线程以完成自身任务
5. 父任务与子任务对核心线程的需求造成了死锁


## 设计模式

## 垃圾回收

### 回收算法
- 标记-清除：直接将标记后的对象进行清除，会产生许多内存碎片，但删除效率高。
- 标记-整理：将标记后的对象进行清除后，整理剩余的对象内存，得到连续的空内存区域，删除效力低但分配内存时效率高。
- 标记-复制：将空间分为两部分，每次回收其中一部分，将存活的对象复制到另一个内存区域，删除效率高，但内存空间浪费严重。

### 分代收集理论
将对象分为新生代（young）和老年代（old），在新生代的对象会有90%被回收，因此可以使用不同的垃圾回收算法对新生代和老年代的对象进行收集。对象通过一个“年龄”从新生代成长至老年代。

### 浮动垃圾
#### 出现情况
- 并发标记过程中插入了一条黑色对象到白色对象的引用
- 并发标记过程中清除了一条灰色对象到白色对象的引用

#### 解决方法
- 增量更新：解决黑色对象新增白色对象引用问题，在出现黑色对象对白色对象引用的过程时，将其记录下来，在并发扫描完成后再进行一次扫描。
- 原始快照：解决灰色对象删除白色对象应引用问题，当灰色对象删除白色对象引用时，将其记录下来，再并发扫描完成后进行重新扫描。
- 虚拟机进行增量更新或原始快照记录时均使用“写屏障”技术，通过写屏障更新指针。

### 新生代垃圾回收器
1. Serial - 结合老年代 1、2
    > 单线程垃圾回收器，在进行垃圾回收时会暂停所有用户线程，直到垃圾回收结束，导致（STW：Stop The World）问题产生，若本地内存很大，这将导致十分严重的问题。新生代垃圾回收使用 标记-复制 方法
2. ParNew - 结合老年代 1、2
    > 多线程的Serial垃圾回收器，可结合CMS使用，新生代垃圾回收使用 标记-复制 方法。
3. Parallel Scavenge - 结合老年代 2、3
    > 并行的使用 标记-复制 方法进行垃圾回收，但其特点在于维护了一个可控制的吞吐量值。
4. G1
    > G1从大体上看也是一个分代垃圾回收器，但其将堆空间划分为一个个小的Region进行管理，实现可控的延迟时间并保证高吞吐量。

    > 标记阶段分为 初始标记→并发标记→最终标记→筛选回收，初始标记阶段会暂停用户线程但速度较快，只需要找到GC Roots，并发标记过程与用户线程并行，最终标记过程包含对并发标记过程中新生成的对象进行标记（使用的是原始快照搜索），最终基于全局标记-整理和局部标记-复制的算法结合停顿预测模型清除最大效益垃圾内存。

### 老年代垃圾回收器
1. CMS - 结合新生代 1、2
    > 基于 标记-清除算法实现，其中标记清楚阶段分为 初始标记→并发标记→重新标记→并发清除，初始标记和重新标记需要STW，并发标记阶段可以和用户线程同步进行。
    
    > CMS同样会导致STW的出现，因为在标记过程中用户线程一直在运行，这就导致一些对象被新建时已经完成一次标记，导致了“ 浮动垃圾 ”出现，CMS无法在本次GC时回收这些浮动垃圾，若浮动垃圾过多导致内存空间无法满足新对象的生成，这时就需要使用 Serial Old对老年代进行一次GC，这时间无法把控，导致STW出现。

    > CMS 可以在一定程度上解决 标注过程中对象消失的问题，使用的是 “增量更新” 方法，记录黑色对象对白色对象的引用，待扫描结束后对这些黑色节点进行重新扫描。
2. Serial Old 结合新生代 1、3
    > Serial版本的老年代垃圾收集器，使用 标记-整理 方法维护老年代内存区域。
3. Parallel Old 结合新生代 3
    > 并发老年代垃圾收集器，其可以配合 新生代Parallel Scavenge垃圾收集器使用，增强并发能力。
4. G1